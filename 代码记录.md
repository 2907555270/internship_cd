# 项目记录

## 源码

### 1. SysMenuServiceImpl.java:

###### 1.1 源码44行:

* **缺陷：**对于多个同时在线的用户，需要保证redis中sys_user与用户不重叠

###### 	1.2  function : covert 81行

* **缺陷：**构建的树展开会有大量的重复，若数据库数据错误存在循环菜单，严重的甚至导致构建树的时候出现死循环
* **改进建议：**基于每个菜单只设置一级子目录，并将每个菜单放在一个Map中，



### 2. Controller

###### 2.1 url接口规范：

* 对每个接口需要<u>明确的action_name指定</u>，不能单纯依靠Method区分，提升可读性

* @RequestMapping()中的value需要在前缀加上 "/"
* 

---



## 数据库优化

### 1. 并发、锁机制

* 【**乐观锁**】为每一张表的末尾添加一个version字段，作为更新的匹配条件，并在每次更新操作时进行version+1操作
  * 假设每次操作都只有自己，不会发生冲突
  * 适合读的多，写的少的情况
* 【**悲观锁**】加锁，直到某个线程执行完毕，释放锁，其他机制才能执行
  * 假设每次操作都会发生冲突
  * 适合读的少，写的多的情况

---



## 业务逻辑

| 业务名       | 处理方式                                                     |
| ------------ | ------------------------------------------------------------ |
| 用户身份信息 | 将用户信息存放在redis中，authorities和sys_user均需要按用户Id进行区分 |









## mysql规约

## 1. 建表规约：

**[强制]	存储引擎必须强制使用InnoDB**

* InnoDB支持事物、行级锁、并发性能更好，CPU及内存缓存页优化使得资源利用率更高

**[强制]	每张表都应设置一个主键ID，且主键ID为自增模式（考虑到唯一ID值-分库分表时可以不用）**

* 主键ID是单调递增的可以有效提高插入的性能，避免过多的页分裂、减少表碎片提高空间的使用率。 
* 在分库分表环境下，则需要统一来分配各个表中的主键值，从而避免整个逻辑表中主键重复。

**[强制]	必须使用utf8mb4字符集**

* 在Mysql中的UTF-8并非“真正的UTF-8”，而utf8mb4”才是真正的“UTF-8”。

**[强制]	禁止使用外键，如果有外键完整性约束，需要应用程序控制**

* 外键会导致表与表之间耦合，UPDATE与DELETE操作都会涉及相关联的表，十分影响SQL的性能，甚至会造成**死锁**

**[强制]	必须把表字段设置为NOT NULL**

- NULL的列使索引/索引统计/值<u>比较都更加复杂，对MySQL来说更难优化</u>；
- NULL这种类型Msql内部<u>需要进行特殊处理</u>，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多；
- NULL值<u>需要更多的存储空间</u>，无论是表还是索引中每行中的NULL的列都<u>需要额外的空间来标识</u>

**[强制]	单表列数目必须小于30，若超过则应该考虑分表**

**[强制]	数据库表、表字段必须加入中文注释**

**[强制]	库名、表名、字段名均小写，下划线风格**

**[建议]	如果存储的字符串长度几乎相等，使用CHAR定长字符串类型**

* 减少空间碎片，节省存储空间

**[建议]	考虑使用TimeStamp替代Datetime**

* TimeStamp<u>占4个字节</u>，能够<u>根据时区转换为对应的时间值</u>
* DateTime<u>占8个字节</u>，能够存储更多的时间（1001-9999），对<u>时区不敏感</u>



---

## 2. SQL规约

**[强制]	为了充分利用缓存，不允许使用自定义函数、存储函数、用户变量**

* 如果查询中包含任何用户<u>自定义函数、存储函数</u>、用户变量、<u>临时表</u>、Mysql库中的<u>系统表</u>，其<u>查询结果都不会被缓存</u>
* 比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果

**[强制]	在查询中指定所需的列，不用* 返回所有的列**

* 读取不需要的列会增加CPU、IO、NET的消耗
* 不能有效地利用覆盖索引

**[强制]	以下操作将导致索引失效**

* 属性的隐式转换

* WHERE条件的属性上使用<u>函数或则表达式</u>（mysql无法自动解析它们）
* 使用 <u>%</u> 开头的模糊查询

**[建议]	尽量避免在WHERE语句中使用or进行条件连接**

* 根据情况使用 <u>UNION ALL</u> 来替代



## 3. 索引规约

**[建议]	避免在更新比较频繁、区分度不高的列上单独建立索引**

* 区分度不高建立索引的效果不明显
* 更新比较频繁会导致索引的维护成本更高

**[强制]	Join的表不允许超过5个；需要join表时，数据类型必须一致；多表关联查询时，保证<u>被关联的字段需要有索引</u>**

* 太多表的Join会让mysql的优化器难以权衡出一个“最佳”的执行计划

**[强制]	在一个联合索引中，若第一列的索引区分度等于1，则不需要建立联合索引**

* 通过索引第一列，即可定位全部数据，后面的索引并没有被使用

**[建议]	利用覆盖索引进行查询，避免回表二次查询**

**[建议]	对于文本字段，采用截断前N个字符建立索引，不需要对全文建立索引**

**[建议]	使用Order By时，需要注意索引的有序性**

* Order By的字段是联合索引的一部分，并且放在索引组合顺序的最后，避免出现filesort
* 查询条件中使用了范围查询，也将导致索引有序性无法使用，需要进行filesort

**[建议]	多个表进行外连接时，表之间的字段类型必须完全一致**

* 否则，索引失效
* <u>完全一致</u>：包括但不限于<u>字段类型，字段长度，字符集等等</u>